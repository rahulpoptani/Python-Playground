symbols = '$¢£¥€¤'

list_com = [ord(x) for x in symbols]
print(list_com)

list_map = list(map(lambda x: ord(x), symbols))
print(list_map)

# Both above operations are doing same, but list comprehension is faster

import array
arr = array.array('I', (ord(x) for x in symbols))
print(arr)

########################################################################################################################

# Using GenExp with Cartesian Product to print out roaster of T-shirts of two colors and three sizes.
# Note: Here the 6 items of t-shirts is NEVER built in memory. The generator expression feeds the for loop producing one item at a time.

colors = ['black', 'white']
sizes = ['S', 'M', 'L']
# Categian Product using Generator Expression (GenExp)
# The generator expression yields items one by one, a list with all six thsirt variations is never produced
for tshirt in (f'{c} {s}' for c in colors for s in sizes):
    print(tshirt)


# Tuples more efficient than list?
# To evaluate a tuple literal, the Python compiler generates bytecode for a tuple constant in one operation, but for a list literal, the generated bytecode pushes each element as a separate constant to the data stack, and then builds the list.
# Given a tuple t, tuple(t) simply returns a reference to the same t. There’s no need to copy. In contrast, given a list l, the list(l) constructor must create a new copy of l.
# Because of its fixed length, a tuple instance is allocated the exact memory space in needs. Instances of list, on the other hand, are allocated with room to spare, to amortize the cost of future appends.
# The references to the items in a tuple are stored in an array in the tuple struct, while a list holds a pointer to an array of references stored elsewhere. The indirection is necessary because when a list grows beyond the space currently allocated, Python needs to realocate the array of references to make room. The extra indirection makes CPU caches less effective. 

########################################################################################################################
# Unpacking
lax_cordinates = (33.9425, -118.408056)
lat, long = lax_cordinates
print(lat, long)

t = (20, 8)
quotient, remainder = divmod(*t) # * unpacks tuple t and further unpacking the quotient and remaider

import os
_, filename = os.path.split("/some/random/path/file.txt")
print(_, filename)


# Using * to grab excess items
a, b, *rest = range(5)
print(a, b, rest)

a, b, *body, c, d = range(9)
print(a, b, body, c, d)


# Another example of unpacking nested tuples

metro_areas = [
    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),  
    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
    ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
]


print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
for name, _, _, (lat, lon) in metro_areas:  
    if lon <= 0:  # only cities in wester hemisphere
        print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')


########################################################################################################################
# Assigning to Slices
print('---------------------------------------')
print('---------------------------------------')
print()


l = list(range(10))
print(l)
print(l[2:5])
l[2:5] = [20, 30]
print(l)

del l[5:7]
print(l)

print(l[3::2])
l[3::2] = [11, 22]
print(l)


# Python Array is as lean as C Array
from array import array
from random import random
floats = array('d', (random() for i in range(10**7))) # Create Array with Double Precision
print(floats[-1])
fp = open('floats.bin', 'wb') 
floats.tofile(fp) # 7 times faster than writing into text file. Also binary file takes 40% space in comparison to text file
fp.close()
floats2 = array('d')
fp = open('floats.bin', 'rb')
floats2.fromfile(fp, 10**7) # Takes 0.1s to load from binary file, 60 times faster than reading from text file
fp.close()
print(floats2[-1])
print(floats2 == floats)


# Array does not have in place sort method, you need to rebuild
a = array('i', [5,6,2,9,4,5,2,1])
print(a)
a = array(a.typecode, sorted(a))
print(a)


# MemoryView class is a sharedmemory sequence type that allow handle array without copying bytes
# Its generalized Numpy array structure in Python. Allows share memory between data structures without first copying
octets = array('B', range(6))
m1 = memoryview(octets)


# Numpy
import numpy as np
a = np.arange(12)
print(a)
print(a.shape)
a.shape = 3,4
print(a.shape)
print(a)
print(a[2])
print(a[2,1])
print(a[:,1])
